import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import jwt from 'jsonwebtoken';
import DatabaseConnectionPool from '../../shared/database/connection-pool.js';
import DualDatabaseWriter from '../../shared/database/dual-writer.js';
import EventStore from '../../shared/event-sourcing/event-store.js';
import { KafkaService } from '../../shared/messaging/kafka-service.js';
import { UserService } from './user-service.js';
import winston from 'winston';

const app = express();
const PORT = process.env.USER_SERVICE_PORT || 3001;

// Logger setup
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/user-service.log' })
  ]
});

// Initialize dependencies
const connectionPool = new DatabaseConnectionPool();
const kafkaService = new KafkaService();
const dualWriter = new DualDatabaseWriter(connectionPool);
const eventStore = new EventStore(connectionPool, kafkaService);

const dependencies = {
  connectionPool,
  dualWriter,
  eventStore,
  kafkaService,
  logger
};

// Initialize UserService
const userService = new UserService(dependencies);

// Middleware
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json({ limit: '10mb' }));

// JWT middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'default-secret', (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = user;
    next();
  });
};

// Authorization middleware
const requireRole = (roles) => {
  return (req, res, next) => {
    if (!req.user || !req.user.roles) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    const hasRole = roles.some(role => req.user.roles.includes(role));
    if (!hasRole) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };
};

// Routes

// Authentication routes
app.post('/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName, phoneNumber, dateOfBirth, address, preferences } = req.body;

    // Validate input
    if (!email || !password || !firstName || !lastName) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields'
      });
    }

    const result = await userService.createUser({
      email,
      password,
      firstName,
      lastName,
      phoneNumber,
      dateOfBirth,
      address,
      preferences,
      metadata: { source: 'api' }
    });

    res.status(201).json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error registering user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Email and password required'
      });
    }

    const result = await userService.authenticateUser(email, password);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error logging in user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.post('/refresh-token', authenticateToken, async (req, res) => {
  try {
    const result = await userService.refreshToken(req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error refreshing token:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// User profile routes
app.get('/profile', authenticateToken, async (req, res) => {
  try {
    const result = await userService.getUserProfile(req.user.userId);

    res.json({
      success: true,
      data: result.profile,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user profile:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.put('/profile', authenticateToken, async (req, res) => {
  try {
    const { firstName, lastName, phoneNumber, dateOfBirth, address } = req.body;

    const result = await userService.updateProfile(req.user.userId, {
      firstName,
      lastName,
      phoneNumber,
      dateOfBirth,
      address
    }, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error updating user profile:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.put('/preferences', authenticateToken, async (req, res) => {
  try {
    const preferences = req.body;

    const result = await userService.updatePreferences(req.user.userId, preferences, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error updating user preferences:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Password management routes
app.put('/password', authenticateToken, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        error: 'Current password and new password required'
      });
    }

    const result = await userService.changePassword(req.user.userId, currentPassword, newPassword, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error changing password:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.post('/reset-password', async (req, res) => {
  try {
    const { email, newPassword, resetToken } = req.body;

    if (!email || !newPassword || !resetToken) {
      return res.status(400).json({
        success: false,
        error: 'Email, new password, and reset token required'
      });
    }

    const result = await userService.resetPassword(email, newPassword, resetToken, 'system');

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error resetting password:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Email verification
app.post('/verify-email', async (req, res) => {
  try {
    const { userId, verificationToken } = req.body;

    if (!userId || !verificationToken) {
      return res.status(400).json({
        success: false,
        error: 'User ID and verification token required'
      });
    }

    const result = await userService.verifyEmail(userId, verificationToken, 'system');

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error verifying email:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Admin routes (require admin role)
app.get('/users', authenticateToken, requireRole(['admin', 'manager']), async (req, res) => {
  try {
    const { page, limit, status, role, sortBy, sortOrder } = req.query;

    const filters = {};
    if (status) filters.status = status;
    if (role) filters.role = role;

    const pagination = {
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 10,
      sortBy: sortBy || 'createdAt',
      sortOrder: sortOrder || 'desc'
    };

    const result = await userService.getUsers(filters, pagination);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting users:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.get('/users/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;

    // Check if user can access this profile (own profile or admin)
    if (req.user.userId !== userId && !req.user.roles.includes('admin')) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    const result = await userService.getUser(userId);

    res.json({
      success: true,
      data: result.user,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.put('/users/:userId', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userId } = req.params;
    const updates = req.body;

    const result = await userService.updateUser(userId, updates, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error updating user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.put('/users/:userId/suspend', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userId } = req.params;
    const { reason, suspensionEndDate } = req.body;

    const result = await userService.suspendUser(userId, reason, suspensionEndDate, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error suspending user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.put('/users/:userId/activate', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userId } = req.params;

    const result = await userService.activateUser(userId, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error activating user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.delete('/users/:userId', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userId } = req.params;
    const { reason } = req.body;

    const result = await userService.deleteUser(userId, reason, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error deleting user:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Role management routes
app.post('/users/:userId/roles', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userId } = req.params;
    const { role } = req.body;

    if (!role) {
      return res.status(400).json({
        success: false,
        error: 'Role required'
      });
    }

    const result = await userService.addRole(userId, role, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error adding user role:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.delete('/users/:userId/roles/:role', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userId, role } = req.params;

    const result = await userService.removeRole(userId, role, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error removing user role:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Analytics and reporting routes
app.get('/analytics/users', authenticateToken, requireRole(['admin', 'manager']), async (req, res) => {
  try {
    const result = await userService.getUserStatistics();

    res.json({
      success: true,
      data: result.statistics,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user statistics:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.get('/analytics/users/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;

    // Check permissions
    if (req.user.userId !== userId && !req.user.roles.includes('admin')) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    const result = await userService.getUserAnalytics(userId);

    res.json({
      success: true,
      data: result.analytics,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user analytics:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.get('/reports/users/:reportType', authenticateToken, requireRole(['admin', 'manager']), async (req, res) => {
  try {
    const { reportType } = req.params;
    const { filters, dateRange } = req.query;

    const result = await userService.getUserReport(reportType, filters, dateRange);

    res.json({
      success: true,
      data: result.report,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user report:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.get('/dashboard', authenticateToken, async (req, res) => {
  try {
    const result = await userService.getUserDashboardData(req.user.userId);

    res.json({
      success: true,
      data: result.dashboard,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user dashboard:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Activity and audit routes
app.get('/activity', authenticateToken, async (req, res) => {
  try {
    const { limit, offset } = req.query;

    const result = await userService.getUserActivity(req.user.userId, {
      limit: parseInt(limit) || 50,
      offset: parseInt(offset) || 0
    });

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user activity:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.get('/audit-trail', authenticateToken, async (req, res) => {
  try {
    const { limit, offset, eventTypes } = req.query;

    const result = await userService.getUserAuditTrail(req.user.userId, {
      limit: parseInt(limit) || 50,
      offset: parseInt(offset) || 0,
      eventTypes: eventTypes ? eventTypes.split(',') : null
    });

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting user audit trail:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Bulk operations routes
app.post('/bulk/users', authenticateToken, requireRole(['admin']), async (req, res) => {
  try {
    const { userIds, updates, reason } = req.body;

    if (!userIds || !updates) {
      return res.status(400).json({
        success: false,
        error: 'User IDs and updates required'
      });
    }

    const result = await userService.bulkUpdateUsers(userIds, updates, req.user.userId, reason);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error in bulk user update:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Security settings routes
app.get('/security-settings', authenticateToken, async (req, res) => {
  try {
    const result = await userService.getUserSecuritySettings(req.user.userId);

    res.json({
      success: true,
      data: result.securitySettings,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error getting security settings:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.put('/security-settings', authenticateToken, async (req, res) => {
  try {
    const securitySettings = req.body;

    const result = await userService.updateUserSecuritySettings(req.user.userId, securitySettings, req.user.userId);

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Error updating security settings:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Health check
app.get('/health', async (req, res) => {
  try {
    const health = await userService.healthCheck();

    res.json({
      ...health,
      service: 'user-service',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(500).json({
      status: 'unhealthy',
      service: 'user-service',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }

// Initialize service
async function initializeService() {
  try {
    await connectionPool.initialize();
    await kafkaService.initialize();
    await eventStore.initialize();

    logger.info(`User Service started on port ${PORT}`);
  } catch (error) {
    logger.error('Failed to initialize User Service:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully...');
  await userService.cleanup();
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully...');
  await userService.cleanup();
  process.exit(0);
});

app.listen(PORT, () => {
  initializeService();
});

export default app;